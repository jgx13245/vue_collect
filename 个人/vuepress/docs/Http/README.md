# http协议

## http协议理解

```html
所谓的http请求其实是建立在一个TCP/IP协议簇上来传输数据的，我们知道http请求其实就是发送http 
请求数据。建立TCP连接，请求，响应。断开连接

其中TCP连接是分四层模型的。

  应用层（http，ftp。。。。。），

  传输层（tcp,udp），

  网络层（icmp,ip.....）,

  数据链路层。

http就在应用层，http吧数据请求给tcp发过去。tcp传输层。tcp报文信息=tcp报文头+tcp报文体、
其中报文头有6中标志。我们常用就是ACK(确认标志),SYN（请求标志）,FIN（关闭标志），
然后就是三次握手，请求数据。响应数据。四次挥手。
```


1. HTTP协议详流程

以一次HTTP请求的整个过程来讲解(DNS解析不讲)：

（1）HTTP起源、


（2）TCP/IP协议、

（3）建立TCP连接、

（4）客户端请求、

（5）服务端响应、

（6）断开TCP连接
<img :src="$withBase('/images/http.png')" alt="foo">

### http起源
- 1991年 伯纳斯·李的提案包含了网络的基本概念并逐步建立了所有必要的工具：

- 提出HTTP (Hypertext Transfer Protocol) 超文本传输协议，允许用户通过单击超链接访问资源；

- 提出使用HTML超文本标记语言(Hypertext Markup Language)作为创建网页的标准；

- 创建了统一资源定位器URL (Uniform Resource Locator)作为网站地址系统，就是沿用至今的http://www URL格式；

- 创建第一个Web浏览器，称为万维网浏览器，这也是一个Web编辑器；

- 创建第一个Web服务器（http://info.cern.ch）以及描述项目本身的第一个Web页面。

### 起源以后，http协议一共有五大特点

- 支持客户/服务器模式。

- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。
- 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。

- 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

- 无状态：无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息（Cookie和Session孕育而生，后期再讲）

### 知道特点后，TCP/IP协议簇是啥

**HTTP是一个基于TCP/IP协议簇来传递数据。**

<img :src="$withBase('/images/tcp.png')" alt="foo">

从上图我们可以清晰的看到HTTP使用的传输层协议为TCP协议，而网络层使用的是IP协议（当然还使用了很多其他协议），所以说HTTP是一个基于TCP/IP协议簇来传递数据。

>同样我们可以看到ping走的ICMP协议，这也就是为什么有时候我们开vps可以上网，但是ping google却ping不通的原因，因为走的是不同的协议。


数据发送端是一层一层封装数据，数据接收端一层一层拆封，最后应用层获得数据。

### TCP/IP协议簇明白后，建立TCP连接

1. **TCP包头信息**

HTTP是一个基于TCP/IP协议簇来传递数据，所以这HTTP建立连接也就是建立TCP连接

<img :src="$withBase('/images/tcp_conn.png')" alt="foo">


TCP报文包=TCP头信息+TCP数据体，而在TCP头信息中包含了6种控制位（上图红色框中），这六种标志位就代表着TCP连接的状态：

URG：紧急数据（urgent data）—这是一条紧急信息

**ACK：确认已收到**

PSH：提示接收端应用程序应该立即从tcp接受缓冲区中读走数据

RST：表示要求对方重新建立连接

**SYN：表示请求建立一个连接**

**FIN：表示通知对方本端要关闭连接了**


<img :src="$withBase('/images/ACK.png')" alt="foo">


**三次握手讲解：**

- 客户端发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，服务器由SYN=1知道客户端要求建立联机（客户端：我要连接你）

- 服务器收到请求后要确认联机信息，向A发送ack number=(客户端的seq+1),syn=1,ack=1,随机产生seq=7654321的包（服务器：好的，你来连吧）

- 客户端收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，客户端会再发送ack number=(服务器的seq+1),ack=1，服务器收到后确认seq值与ack=1则连接建立成功。（客户端：好的，我来了）

::: tip
<font color=red>为什么是三次呢</font>

因为两次不可靠,四次浪费资源
:::


<img :src="$withBase('/images/cishu.png')" alt="foo">

### 建立连接之后，客户端请求

现在可以发送http请求了。

1. **HTTP请求报文结构**

我们之前说过TCP报文包=TCP头信息+TCP数据体，TCP头信息我们已经讲了，现在来讲TCP数据体，也就是我们的HTTP请求报文。

<img :src="$withBase('/images/body.png')" alt="foo">

### 客户端请求后，服务端响应

服务器在收到客户端请求处理完需要响应并返回给客户端，而HTTP响应报文结构与请求结构体一致。

<img :src="$withBase('/images/res.png')" alt="foo">

接下来就是 响应状态码了

1. 2xx 成功

2. 3xx 缓存 （问的最多）为什么304啊----> [点这里知道](http://www.jiguangxin.cn/BrowserPrinciple/#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98)

3. 4xx 页面路径有问题

4. 5xx 服务器问题


### 服务端响应完，断开连接

在服务器响应完毕后，一次会话就结束了，请问这时候连接会断开吗？

1. **长短连接**

是否断开我们需要区分HTTP版本：

在HTTP/1.0版本的时候，客户端与服务器完成一个请求/响应之后，会将之前建立的TCP连接断开，下次请求的时候又要重新建立TCP连接，这也被称为短连接

在HTTP1.0发布仅半年后（1997年1月） ，HTTP/1.1版本发布并带来一个新的功能：在客户端与服务器完成一次请求/响应之后，允许不断开TCP连接，这意味着下次请求就直接使用这个TCP连接而不再需要重新握手建立新连接，这也被称为长连接



注意：长连接是指一次TCP连接允许多次HTTP会话，HTTP永远都是一次请求/响应，会话结束，HTTP本身不存在长连接之说。



早在1999年HTTP1.1就推广普及，所以现在浏览器在请求时请求头中都会携带一个参数：Connection:keep-alive，这表示浏览器要求与服务器建立长连接，而服务器也可以设置是否愿意建立长连接。



2. **长连接优缺点**

对于服务器来说建立长连接有优点也有缺点：

优点：当网站中有大量静态资源（图片、css、js等）就可以开启长连接，这也几张图片就可以通过一次TCP连接发送。

缺点：当客户端请求一次时候不在请求，而服务器却开着长连接资源被占用着，这是严重浪费资源。



所以是否开启长连接，长连接时间都需要根据网站自身来合理设置。



ps：大家不要小看这一个TCP连接，在一次客户端HTTP完整的请求中（DNS寻址、建立TCP连接、请求、等待、解析网页、断开TCP连接）建立TCP连接占用的时间比还是很大的。

3. **断开连接过程**

<img :src="$withBase('/images/tcp4.png')" alt="foo">

**四次挥手**

（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），
     Server进入CLOSE_WAIT状态。

（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，
     Server进入CLOSED状态，完成四次挥手。

::: tip
<font color=red>为什么是4四次呢</font>

确保数据能够完整传输。

当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。

但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET,它可能还需要发送一些数据给主动方后，

再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。

client先发送FIN告知对方我已经完成数据发送了，server回复ack来确定我知道了。这样一个流程，就关闭了client的发送信息通道。但是还可以接收来自server方的数据。

server此时已经知道接收不到client的数据了，但是还可以给它发送数据。如果server也没有啥数据要发送给对方了，server也会以FIN标志位发送一个信息给client，client接到后，也会传递一个ack表示知道了。这样子，双方都完成了关闭。

:::
